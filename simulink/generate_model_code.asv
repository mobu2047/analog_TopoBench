
    % 打开文件准备写入代码
    fid = fopen('inverter_model.m', 'w');
    model_name = untitled;
    
    % 写入函数头
    fprintf(fid, 'function create_inverter_model()\n');
    fprintf(fid, '    %% 创建单相桥式逆变器模型\n');
    fprintf(fid, '    model_name = ''%s_generated'';\n', model_name); % 修改模型名称避免冲突
    fprintf(fid, '    new_system(model_name);\n');
    fprintf(fid, '    open_system(model_name);\n\n');

  
    
    % 获取模型中的所有块
    blocks = find_system(model_name, 'SearchDepth', 1);
    
    % 跳过模型本身
    blocks = blocks(2:end);
    for i = 1:length(blocks)
        disp(getfullname(blocks(i,1)));
    end
% 获取模型中所有“线”对象（信号线）
% 说明：这一步覆盖普通 Simulink 信号线；但拿不到物理网络线（如 RLC 两端子线）
all_blocks = find_system(model_name, 'SearchDepth',1,'FindAll','on', ...
    'LookUnderMasks','on', 'FollowLinks','on', 'type','line');

% 创建一个空的结构体或单元格数组来存储连接关系
connectivity = {};
% 去重：源块全名|源端口 => 目标块全名|目标端口
conn_keys = containers.Map('KeyType','char','ValueType','logical');

% 遍历每条“信号线”，并递归遍历分支（避免漏掉 LineChildren）
for i = 1:length(all_blocks)
    block = all_blocks(i,1);               % 实际是 line 句柄，沿用你的变量名

    src_port = get_param(block, 'SrcPortHandle');
    dst_ports = get_param(block, 'DstPortHandle'); %保留你的原变量（后续我们用递归统一收集）
    if src_port ~= -1
        src_block = get_param(src_port, 'Parent');
        src_block_name = get_param(src_block, 'Name');
        src_block_full = getfullname(src_block);
        src_port_num = get_param(src_port, 'PortNumber');

        % 递归获取该线及全部分支的目标端口
        visited_lines = [];
        [dst_blk_handles, dst_port_handles, visited_lines] = collect_all_dsts(block, visited_lines);

        % 处理所有目标
        for j = 1:length(dst_port_handles)
            if dst_port_handles(j) ~= -1
                dst_block = dst_blk_handles(j);
                dst_block_name = get_param(dst_block, 'Name');
                dst_block_full = getfullname(dst_block);
                dst_port_num = get_param(dst_port_handles(j), 'PortNumber');

                key = sprintf('%s|%d=>%s|%d', src_block_full, src_port_num, dst_block_full, dst_port_num);
                if ~isKey(conn_keys, key)
                    conn_keys(key) = true;
                    connectivity{end+1} = struct( ...
                        'Source',          src_block_name, ...
                        'SourcePort',      src_port_num, ...
                        'Destination',     dst_block_name, ...
                        'DestinationPort', dst_port_num ...
                    );
                    disp(['Line from ', src_block_name, '(', num2str(src_port_num), ') to ', ...
                                      dst_block_name, '(', num2str(dst_port_num), ')']);
                end
            end
        end
    end
end

% ========= 新增：基于 PortConnectivity 的扫描 =========
all_blocks_pc = find_system(model_root, 'FindAll', 'on', 'LookUnderMasks','all','FollowLinks','on', 'Type',  'block' );  % 不限制层级，确保掩模/链接下的端口也统计

for i = 1:length(all_blocks_pc)
    bh = all_blocks_pc(i);
    pc = get_param(bh, 'PortConnectivity');  % 每个端口的上下游连接信息（同时支持物理连接与信号线）

    % 遍历该块的每个端口连接
    for p = 1:numel(pc)
        % 1) 作为“输出端口”一侧：本块 -> 下游块（包含信号与物理端口）
        if isfield(pc(p),'DstBlock') && ~isempty(pc(p).DstBlock) && all(pc(p).DstBlock ~= -1)
            src_block_full = getfullname(bh);
            src_block_name = get_param(bh, 'Name');
            src_port_num   = get_port_num(pc(p));   % 当前端口号% 目的：覆盖“物理网络线”（如 RLC、开关、电感等的保守端口连接），这些不是普通的信号线
            for d = 1:numel(pc(p).DstBlock)
                dst_bh        = pc(p).DstBlock(d);
                dst_block_full= getfullname(dst_bh);
                dst_block_name= get_param(dst_bh, 'Name');
                dst_port_num  = pc(p).DstPort(d);

                key = sprintf('%s|%d=>%s|%d', src_block_full, src_port_num, dst_block_full, dst_port_num);
                if ~isKey(conn_keys, key)
                    conn_keys(key) = true;
                    connectivity{end+1} = struct( ...
                        'Source',          src_block_name, ...
                        'SourcePort',      src_port_num, ...
                        'Destination',     dst_block_name, ...
                        'DestinationPort', dst_port_num ...
                    );
                    % 标识来源于 PortConnectivity（帮助你区分两条路径）
                    disp(['Line from ', src_block_name, '(', num2str(src_port_num), ') to ', ...
                                      dst_block_name, '(', num2str(dst_port_num), ') [PC]']);
                end
            end
        end

        % 2) 作为“输入端口”一侧：上游块 -> 本块（物理端口常为双向，这里也补齐）
        if isfield(pc(p),'SrcBlock') && ~isempty(pc(p).SrcBlock) && pc(p).SrcBlock ~= -1
            src_bh         = pc(p).SrcBlock;
            src_block_full = getfullname(src_bh);
            src_block_name = get_param(src_bh, 'Name');
            src_port_num   = get_port_num(pc(p)); 

            dst_block_full = getfullname(bh);
            dst_block_name = get_param(bh, 'Name');
            dst_port_num   = get_port_num(pc(p)); 

            key = sprintf('%s|%d=>%s|%d', src_block_full, src_port_num, dst_block_full, dst_port_num);
            if ~isKey(conn_keys, key)
                conn_keys(key) = true;
                connectivity{end+1} = struct( ...
                    'Source',          src_block_name, ...
                    'SourcePort',      src_port_num, ...
                    'Destination',     dst_block_name, ...
                    'DestinationPort', dst_port_num ...
                );
                disp(['Line from ', src_block_name, '(', num2str(src_port_num), ') to ', ...
                                  dst_block_name, '(', num2str(dst_port_num), ') [PC]']);
            end
        end
    end
end

% 现在 connectivity 单元格数组包含了所有的源-目标连接对（信号线 + 物理网络线）
for i = 1:length(connectivity)
    disp(connectivity{1,i});
end
% ============================================================
% 采集所有元件（block）的位置信息（像素坐标，原点为画布左上）
% why: 后续可视化/导出需要几何信息；保持与连接表同一根模型
% ============================================================



% 拿到所有 block 句柄（包含掩模/链接/变体）
all_blocks_for_pos = all_blocks_pc;

% 结果容器：元件、端口（可选）、连线（可选）
elements = struct('Path',{},'Name',{},'BlockType',{},'Orientation',{}, ...
                  'Position',{},'Center',{},'LibraryLink',{});
ports    = struct('BlockPath',{},'PortNumber',{},'PortType',{},'Position',{});
sigLines = struct('Handle',{},'IsRoot',{},'SrcPath',{},'DstPaths',{},'Points',{});

% ========== A) 元件位置 ==========
for i = 1:numel(all_blocks_for_pos)
    bh = all_blocks_for_pos(i);

    % 元件基础信息
    path  = getfullname(bh);
    name  = get_param(bh,'Name');
    btype = get_param(bh,'BlockType');              % 某些掩模块可能为空字符串
    ori   = get_param(bh,'Orientation');            % right/left/up/down
    pos   = get_param(bh,'Position');               % [L T R B]
    ctr   = [(pos(1)+pos(3))/2, (pos(2)+pos(4))/2]; % 中心点
    lib   = '';
    if strcmp(get_param(bh,'LinkStatus'),'resolved')
        lib = get_param(bh,'ReferenceBlock');       % 来自库的引用路径
    end

    elements(end+1) = struct( ...                   %#ok<AGROW>
        'Path',        path, ...
        'Name',        name, ...
        'BlockType',   btype, ...
        'Orientation', ori, ...
        'Position',    pos, ...
        'Center',      ctr, ...
        'LibraryLink', lib ...
    );
end

% ========== B) 端口位置（可选，但强烈建议一起存） ==========
% why: 即使某些“物理网络线”没有常规 line 对象，也能用端口坐标重建边
for i = 1:numel(all_blocks_for_pos)
    bh = all_blocks_for_pos(i);
    path = getfullname(bh);

    pc = get_param(bh,'PortConnectivity');  % 端口连接与几何信息
    for p = 1:numel(pc)
        pnum = get_port_num(pc(p));         % 兼容 PortNumber/Port
        ppos = get_port_position(pc(p), bh);% 优先用 pc(p).Position，必要时回退到句柄
        ptyp = '';
        if isfield(pc(p),'Type') && ~isempty(pc(p).Type)
            ptyp = pc(p).Type;              % inport/outport/conserving等；若为空再粗略判断
        else
            if ~isempty(pc(p).DstBlock) && all(pc(p).DstBlock~=-1)
                ptyp = 'outport';
            elseif ~isempty(pc(p).SrcBlock) && pc(p).SrcBlock~=-1
                ptyp = 'inport';
            else
                ptyp = 'port';
            end
        end

        ports(end+1) = struct( ...          %#ok<AGROW>
            'BlockPath',  path, ...
            'PortNumber', pnum, ...
            'PortType',   ptyp, ...
            'Position',   ppos ...
        );
    end
end

% ========== C) 常规信号线的折线坐标（可选） ==========
% why: 普通 Simulink 信号线有 line 对象，能直接拿 polyline 点；物理线若没有，则用 B) 的端点重建
all_lines = find_system(model_root,'FindAll','on','Type','line', ...
    'SearchDepth',Inf,'LookUnderMasks','all','FollowLinks','on');
for i = 1:numel(all_lines)
    lh = all_lines(i);
    srcH = get_param(lh,'SrcPortHandle');
    isRoot = srcH ~= -1;

    % 源与目标（注意：branch line 也有自己的 Dst 集合）
    srcPath = '';
    if isRoot
        srcPath = getfullname(get_param(srcH,'Parent'));
    end
    dstHs = get_param(lh,'DstBlockHandle');
    if isequal(dstHs,-1) || isempty(dstHs)
        dstPaths = {};
    else
        dstPaths = arrayfun(@(h)getfullname(h), dstHs(:),'UniformOutput',false);
    end

    pts = get_param(lh,'Points'); % Nx2 折线坐标
    sigLines(end+1) = struct( ... %#ok<AGROW>
        'Handle',  lh, ...
        'IsRoot',  isRoot, ...
        'SrcPath', srcPath, ...
        'DstPaths',{dstPaths}, ...
        'Points',  pts ...
    );
end

% 你现在拥有：
% elements  -> 所有元件的几何信息（位置/中心/朝向/库链接）
% ports     -> 所有端口的像素坐标（可用于重建物理连接）
% sigLines  -> 所有常规“信号线”的折线点集
% 可按需保存为 MAT/JSON，或与 connectivity 表进行 join
% =========
% 工具函数：递归收集“某条线及其所有分支”的目标端口（仅对普通信号线有效）
% =========
function [dstBlks, dstPorts, visited_lines] = collect_all_dsts(line_h, visited_lines)
    if any(visited_lines == line_h)
        dstBlks = [];
        dstPorts = [];
        return;
    end
    visited_lines(end+1) = line_h; %#ok<AGROW>

    dstBlks  = get_param(line_h,'DstBlockHandle');
    dstPorts = get_param(line_h,'DstPortHandle');
    if isequal(dstBlks, -1) || isempty(dstBlks)
        dstBlks = [];
        dstPorts = [];
    end

    children = get_param(line_h,'LineChildren');
    if ~isequal(children, -1) && ~isempty(children)
        for t = 1:numel(children)
            [cBlks, cPorts, visited_lines] = collect_all_dsts(children(t), visited_lines);
            if ~isempty(cBlks)
                dstBlks  = [dstBlks(:);  cBlks(:) ];
                dstPorts = [dstPorts(:); cPorts(:)]; 
            end
        end
    end
end
function n = get_port_num(pcEntry)
    % 兼容不同版本的 PortConnectivity 字段差异
    if isfield(pcEntry, 'PortNumber') && ~isempty(pcEntry.PortNumber)
        n = pcEntry.PortNumber;
    elseif isfield(pcEntry, 'Port') && ~isempty(pcEntry.Port)
        n = pcEntry.Port;
    else
        % 某些特殊端口（如物理端口）可能没有编号，这里返回 NaN 以示区分
        n = NaN;
    end
end

function [rootName, mdlHandle] = ensure_model_loaded(nameOrPath)
    % 兼容：根名/子系统路径/.slx|.mdl 文件路径；避免对非法名字调用 bdIsLoaded
    if isa(nameOrPath,'string'); nameOrPath = char(nameOrPath); end
    rootName  = '';
    mdlHandle = [];

    % 1) 如果是已加载的根名或子系统路径（合法变量名才检查 bdIsLoaded）
    try
        r = bdroot(nameOrPath);      % 若传路径/子系统，也能还原根
        if ~isempty(r) && isvarname(r)
            if bdIsLoaded(r)
                rootName  = r;
                mdlHandle = get_param(r,'Handle');
                return;
            end
        end
    catch
        % 忽略，进入文件路径尝试
    end

    % 2) 作为“文件路径/文件名”尝试加载
    if exist(nameOrPath,'file') == 2
        mdlHandle = load_system(nameOrPath);            % 支持绝对/相对路径，含扩展名
        rootName  = get_param(mdlHandle,'Name');        % 取真实的根名（合法变量名）
        return;
    end

    % 3) 拆解后尝试 .slx / .mdl / 纯根名
    [folder, base, ext] = fileparts(nameOrPath);
    candidates = {};
    if ~isempty(ext)      % 已带扩展
        candidates = {nameOrPath};
    else
        % 无扩展：依次尝试 base.slx, base.mdl, base
        candidates = {fullfile(folder,[base '.slx']), fullfile(folder,[base '.mdl']), base};
    end
    for k = 1:numel(candidates)
        c = candidates{k};
        if exist(c,'file') == 2
            mdlHandle = load_system(c);
            rootName  = get_param(mdlHandle,'Name');
            return;
        elseif isvarname(c)
            try
                mdlHandle = load_system(c);
                rootName  = get_param(mdlHandle,'Name');
                return;
            catch
            end
        end
    end

    error('无法识别/加载模型：%s。请提供根模型名或有效的 .slx/.mdl 路径。', nameOrPath);
end
